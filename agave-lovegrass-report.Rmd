---
title: "Palmer's Agave & Lehmann Lovegrass"
author: "Jeff Oliver"
date: "March 25, 2020"
output: 
  pdf_document: default
  word_document: default
---

```{r setup, include = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, fig.height = 3)
suppressPackageStartupMessages(library(lme4))       # glmer logistic models
suppressPackageStartupMessages(library(broom))      # Clean up stats tables
suppressPackageStartupMessages(library(lmerTest))   # lme models
suppressPackageStartupMessages(library(emmeans))    # post-hoc tests
suppressPackageStartupMessages(library(dplyr))      # Data wrangling
suppressPackageStartupMessages(library(ggplot2))    # Visualization
suppressPackageStartupMessages(library(extrafont))  # For Times New Roman font
# loadfonts()
```

```{r}
# TODO
# 4. See if there is an easy way to add outliers to plots while using 
# stat_summary instead of geom_boxplot; it can be done, but requires re-thinking 
# of how to add survivorship values. Code is included but commented out. Search
# for boxplot_outliers
```

# Summary
A trio of questions on agave (_Agave palmeri_) survival and growth as effected by the invasive, Lehmann lovegrass (_Eragrostis lehmanniana_). To address these questions, I used a mixed-model approach, so the plot variable could be included as a random effect.

```{r data-import}
coronado_data <- read.csv(file = "data/coronado-data-clean.csv",
                          stringsAsFactors = FALSE)

# Treatments are sometimes referred to in different ways, i.e. J+S and S+J are 
# both present in data set, but mean the same thing.
coronado_data$Treatment[coronado_data$Treatment == "S+J"] <- "J+S"
coronado_data$Treatment[coronado_data$Treatment == "H+J"] <- "J+H" # may not occur
coronado_data$Treatment[coronado_data$Treatment == "W+J"] <- "J+W"
coronado_data$Treatment[coronado_data$Treatment == "W+S"] <- "S+W"

# The reference treatment should be control, C.

# Treatments will need to be put in separate columns for regression
# Javalina protection
# J and J+S and J+W and J+H
coronado_data$Javalina <- 0
coronado_data$Javalina[coronado_data$Treatment %in% c("J", "J+S", "J+W", "J+H")] <- 1
coronado_data$Javalina <- factor(coronado_data$Javalina)

# Shade cloth
# S and J+S and S+H and S+W
coronado_data$Shade <- 0
coronado_data$Shade[coronado_data$Treatment %in% c("S", "J+S", "S+H", "S+W")] <- 1
coronado_data$Shade <- factor(coronado_data$Shade)

# Weed eating
# W and J+W and W+H
coronado_data$Weed_eating <- 0
coronado_data$Weed_eating[coronado_data$Treatment %in% c("W", "J+W", "W+H", "S+W")] <- 1
coronado_data$Weed_eating <- factor(coronado_data$Weed_eating)

# Hand pulling
# H and J+H and S+H
coronado_data$Hand_pulling <- 0
coronado_data$Hand_pulling[coronado_data$Treatment %in% c("H", "J+H", "S+H")] <- 1
coronado_data$Hand_pulling <- factor(coronado_data$Hand_pulling)

# Add "Status" column to indicate live or dead for agaves
coronado_data$Status <- NA
coronado_data$Status[coronado_data$Species == "agave"] <- 1
coronado_data$Status[coronado_data$live_leaf_number %in% c("D", "D/P", "P")] <- 0

# Only need agave data for analyses
agave_data <- coronado_data[coronado_data$Species == "agave", ]

# Drop areial_cover.. column (will come from lovegrass rows)
to_drop <- which(colnames(agave_data) == "areial_cover")
agave_data <- agave_data[, -to_drop]

# But still need lehmann lovegarss [sic] cover for some analyses, so a merge
# is required
lehman_data <- coronado_data[coronado_data$Species == "Lehmann lovegarss", ]
lehman_data <- lehman_data[, c("plot", "Row", "plant.num", "areial_cover")]
agave_data <- merge(x = agave_data, y = lehman_data)
```

## 0. Data summary

Following data cleaning, the total number of replicates and plants in each treatment is:

```{r data-summary, message = FALSE}
agave_summary <- agave_data %>%
  group_by(Treatment) %>%
  summarize(num_reps = length(unique(paste0(plot, Row))),
            num_plants = n())

knitr::kable(x = agave_summary,
             format = "markdown", 
             row.names = FALSE,
             col.names = c("Treatment", "# Replicates", "# Plants"))
```

## 1. How does treatment affect agave survival and size?

The two response variables are:

1. The total number of live plants in a row (all those not marked as dead or predated)
2. The number of leaves on agave plants; the number of agaves measured varies among plot/treatment combinations

The inclusion of treatment in the models can be done in two different ways:

1. Treatment is treated as a single predictor variable, with `r length(unique(agave_data$Treatment))` levels, including the control.
2. Treatment is separated into multiple binary predictor variables; indicating whether or not a specific treatment (i.e. Javalina protection) was applied.

### 1.1 How does treatment affect agave survival _s.s._?

In this model, survival is treated as a binary response variable and a logistic regression model is applied (N = `r nrow(agave_data)`).


```{r prep-live-agave-data}
# For figure, want to include survivorship values for each treatment

# Start by dropping all dead plants
live_agave_data <- agave_data[agave_data$Status == 1, ]

# Now all values in live_leaf_number should be numeric
live_agave_data$live_leaf_number <- as.integer(live_agave_data$live_leaf_number)

# Drop any remaining rows with NA for leaf count
live_agave_data <- live_agave_data[!is.na(live_agave_data$live_leaf_number), ]

# For plot & analyses, only consider a maximum of 3 leaves for any 
# plot/row/treatment combination (group %>% slice %>% ungroup)
max_agaves <- 3
live_agave_data <- live_agave_data %>%
  group_by(plot, Row) %>%
  slice(1:max_agaves) %>%
  ungroup()
```

```{r calculate-counts-survivorship}
# For boxplots of counts and size (leaf number), want to include text for each 
# treatment showing the survivorship for that treatment. The positioning of the 
# text labels (right above the upper whisker) requires calculating where the 
# upper whisker will end.

# Start by calculating mean survivorship for each treatment
survivorship <- agave_data %>%
  group_by(Treatment) %>%
  summarize(mean_survivorship = round(x = mean(sum(Status)/n()), digits = 2))

# Because the text will be on the graph of agave counts, we are looking at the 
# counts of live agave to determine positioning of text.
agave_counts <- agave_data %>%
  group_by(plot, Treatment) %>%
  summarize(num_alive = sum(Status))

# Put label at end of upper whisker, which is the 95% quantile of counts
count_whisker <- agave_counts %>%
  ungroup() %>%
  group_by(Treatment) %>%
  summarize(upper_whisker = quantile(x = num_alive, prob = 0.95))

# Merge survivorship values (text for plot) with whisker values (for 
# positioning) text on the plot
survive_text_counts <- merge(x = survivorship,
                             y = count_whisker,
                             by = "Treatment")

# Text to print under each boxplot, indicating what the whiskers mean
boxplot_text <- "Boxplots show median (center line), 25th and 75th percentiles (lower and upper box boundaries, respectively), and 5th and 95th percentiles (lower and upper whisker, respectively)"

# Text to print under boxplot, indicating what the asterisks mean
asterisk_text <- "Asterisks indicate treatments that had a significantly different effect from the Control treatment in Tukey _post-hoc_ tests."
```

```{r prep-survival, warning = FALSE}
# Data wrangling for analysis and eventually plotting of survival data

# Re-level so Control (C) is reference and treatments are plotted in desired 
# order
agave_counts$Treatment <- factor(agave_counts$Treatment,
                                 levels = c("C", "J", "J+S", "J+H", "J+W",
                                            "S", "S+H", "S+W", "H", "W"))

# Function to use with stat_summary for non-default value for whiskers
# See https://stackoverflow.com/questions/21310609/ggplot2-box-whisker-plot-show-95-confidence-intervals-remove-outliers
boxplot_quantiles <- function(x, probs = c(0.05, 0.25, 0.5, 0.75, 0.95)) {
  q_vec <- quantile(x, probs = probs)
  names(q_vec) <- c("ymin", "lower", "middle", "upper", "ymax")
  return(q_vec)
}

# Function for adding outliers to boxplots; using stat_summary with the 
# boxplot_quantiles function (above) will not plot outliers, so we subset those
# data in a separate geom
# See https://stackoverflow.com/questions/35274849/error-in-stat-summaryfun-y-when-plotting-outliers-in-a-modified-ggplot-boxplot
boxplot_outliers <- function(x, limits = c(0.05, 0.95)) {
  outliers <- subset(x = x,
                     x < quantile(x = x, probs = limits[1]) | 
                       x > quantile(x = x, probs = limits[2]))
  return(outliers)
}
```

#### 1.1.a Treatment as a single predictor

For the method of predicting based on treatment, there is a single fixed-effect in the model:

$$
Log{-}odds \enspace Survival = \beta_0 + \beta_1 \times Treatment + b_0
$$

Where $b_0$ is the random intercept for plot.

```{r survival-single-treatment, warning = FALSE}
# Treating "Treatment" as a single variable
surv_single <- glmer(formula = Status ~ Treatment + (1|plot),
                     data = agave_data,
                     family = binomial(link = "logit"))
surv_single_summary <- summary(surv_single)

# Pull out the coefficients
surv_single_coeffs <- surv_single_summary$coefficients

# Tidy up coefficients
surv_single_coeffs <- bind_cols(data.frame(rownames(surv_single_summary$coefficients)),
                                data.frame(round(surv_single_coeffs, digits = 5)))

# Update column names
colnames(surv_single_coeffs) <- c("Predictor", "Estimate", "Std.Error", "z.value", "p.value")

# Remove "Treatment"
surv_single_coeffs$Predictor <- gsub(pattern = "Treatment",
                                     replacement = "",
                                     x = surv_single_coeffs$Predictor)

# Ensure small p-values are not shown as zero
surv_single_coeffs$p.value <- as.character(ifelse(
  test = surv_single_coeffs$p.value < 1e-5,
  yes = signif(x = surv_single_coeffs$p.value, digits = 5),
  no = round(x = surv_single_coeffs$p.value, digits = 5)))

knitr::kable(x = surv_single_coeffs[, c(1, 2, 3, 5)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```

```{r survival-single-post-hoc}
# Run Tukey post-hoc tests for pairwise comparisons
surv_single_post_hoc <- emmeans(surv_single, 
                                "Treatment", 
                                adjust = "tukey")

# Extract the pairwise contrasts table
surv_single_contrasts <- as.data.frame(pairs(surv_single_post_hoc))

# Only concerned with values relative to control treatment
surv_single_contrasts <- surv_single_contrasts[substr(x = surv_single_contrasts$contrast, start = 1, stop = 3) == "C -", ]

# Make a nice format for printing before reducing to only significant effects
surv_single_contrasts_print <- surv_single_contrasts
surv_single_contrasts_print$contrast <- gsub(x = surv_single_contrasts_print$contrast,
                                             pattern = "C - ",
                                             replacement = "")

# And will only need to add asterisks where the post hoc tests were significant
surv_single_contrasts <- surv_single_contrasts[surv_single_contrasts$p.value < 0.05, ]

if (nrow(surv_single_contrasts) > 0) {
  # Extract the name of the treatments that differ from the control; will use 
  # these to identify the corresponding level in the Treatment factor so we can 
  # find x-axis placement of the asterisk
  surv_single_diffs <- gsub(x = surv_single_contrasts$contrast,
                            pattern = "C - ",
                            replacement = "")
  
  # Will need to use survive_text_counts to get appropriate placement of 
  # asterisks in y dimension
  surv_single_asterisks <- survive_text_counts[survive_text_counts$Treatment %in% surv_single_diffs, ]
  surv_single_asterisks$text <- "*"
}
```

_Post-hoc_ comparisons among treatments, showing results of Tukey test for significant differences from the Control treatment:

```{r surv-single-post-hoc-table}
knitr::kable(x = surv_single_contrasts_print[, c(1, 5, 6)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "t value", "P-value"))
```

```{r plot-survival, warning = FALSE}
# A box plot with Treatment on x-axis, # live plants/plot on y; agave counts 
# already calculated in calculate-counts-survivorship block, above
count_caption <- boxplot_text
if (nrow(surv_single_contrasts) > 0) {
  count_caption <- paste0(count_caption, " ", asterisk_text)
}

agave_count_plot <- ggplot(data = agave_counts, mapping = aes(x = Treatment, y = num_alive)) +
  stat_summary(fun.data = boxplot_quantiles, geom = "boxplot") +
  # stat_summary(fun.y = boxplot_outliers, geom = "point") +
  labs(title = "Figure 1.1. Agave survival by treatment",
       x = "Treatment",
       y = "Number of live agaves") +
  geom_text(data = survive_text_counts,
            # referring to bare column won't work for label
            label = survive_text_counts$mean_survivorship, 
            nudge_y = 0.6, # move labels above upper whisker
            mapping = aes(x = Treatment, y = upper_whisker),
            size = 4,
            family = "Times New Roman") +
  theme_bw() +
  theme(text = element_text(family = "Times New Roman"))

# Only add asterisks if there are some
if (nrow(surv_single_contrasts) > 0) {
  agave_count_plot <- agave_count_plot +
  geom_text(data = surv_single_asterisks,
            label = surv_single_asterisks$text,
            nudge_y = 0.1,
            nudge_x = 0.1,
            mapping = aes(x = Treatment, y = upper_whisker),
            size = 5,
            family = "Times New Roman")
}
print(agave_count_plot)
suppressMessages(expr = ggsave(filename = "output/agave-count-plot.pdf", plot = agave_count_plot))
```
`r count_caption`

##### Aside: interpreting logistic regression

Interpreting the results of logistic regression in terms of probabilities requires examination of how the log-odds model works. We are primarily interested in the probability of survival for given values of $Treatment$, i.e. $p(Survival|Treatment)$. We can model this with the logistic function:

$$
p(Survival|Treatment) = \frac{e^{\beta_{0} + \beta_{1}Treatment}}{1 + e^{\beta_{0} + \beta_{1}Treatment}}
$$

However, the relationship between our variable of interest ($p(Survival)$) and the predictor ($Treatment$) is not linear. Using some algebraic rearranging, we arrive at the logit model:
$$
p(Survival|Treatment) = \frac{e^{\beta_{0} + \beta_{1}Treatment}}{1 + e^{\beta_{0} + \beta_{1}Treatment}}
$$

$$
p(Survival|Treatment) \times (1 + e^{\beta_{0} + \beta_{1}Treatment}) = e^{\beta_{0} + \beta_{1}Treatment}
$$

$$
p(Survival|Treatment) + p(Survival|Treatment) \times e^{\beta_{0} + \beta_{1}Treatment} = e^{\beta_{0} + \beta_{1}Treatment}
$$

$$
p(Survival|Treatment) = e^{\beta_{0} + \beta_{1}Treatment} - p(Survival|Treatment) \times e^{\beta_{0} + \beta_{1}Treatment}
$$

$$
p(Survival|Treatment) = e^{\beta_{0} + \beta_{1}Treatment} \times (1 - p(Survival|Treatment))
$$

$$
\frac{p(Survival|Treatment)}{1 - p(Survival|Treatment)} = e^{\beta_{0} + \beta_{1}Treatment}
$$

Finally, we take the natural logarithm of both sides to get:
$$
ln \left(\frac{p(Survival|Treatment)}{1 - p(Survival|Treatment)}\right) = \beta_{0} + \beta_{1}Treatment
$$

Which is the familiar log-odds model from above:
$$
Log{-}odds \enspace Survival = \beta_0 + \beta_1 \times Treatment
$$

So how do we interpret the $\beta$ coefficients from the model? For this model, let us compare the probability of survival in the Control treatment and the probability of survival in the hand-pulling treatment. We can use the original probability model, but because it is the control, we drop the $\beta_{1}Treatment$ terms because $Treatment$ in this case is zero.

$$
p(Survival|Treatment = Control) = \frac{e^{\beta_{0}}}{1 + e^{\beta_{0}}}
$$

substituting in the value for $\beta_{0} = `r round(surv_single_coeffs[1, 2], digits = 3)`$,

```{r extract-surv-betas, echo = FALSE}
b_0 <- round(surv_single_coeffs[1, 2], digits = 3)
b_1 <- round(surv_single_coeffs[2, 2], digits = 3)
```

$$
p(Survival|Treatment = Control) = \frac{e^{`r b_0`}}{1 + e^{`r b_0`}}
$$

```{r control-prob, echo = FALSE}
p_c <- exp(x = surv_single_coeffs[1, 2]) / (1 + exp(x = surv_single_coeffs[1, 2]))
p_c <- round(p_c, digits = 3)
```

And the estimated probability for survival in the Control group is then `r p_c`.

For the survival probability of the hand-pulling treatment, we start with the same probability model:

$$
p(Survival|Treatment = Hand-pulling) = \frac{e^{\beta_{0} + \beta_{1}Treatment}}{1 + e^{\beta_{0} + \beta_{1}Treatment}}
$$

Set $Treatment$ equal to 1 and use the coefficient estimate from the table above for $\beta_{1} = `r round(surv_single_coeffs[2, 2], digits = 3)`$:

$$
p(Survival|Treatment = Hand-pulling) = \frac{e^{`r b_0` + `r b_1`}}{1 + e^{`r b_0` + `r b_1`}}
$$

```{r hand-pulling-prob, echo = FALSE}
p_h <- exp(x = (surv_single_coeffs[1, 2] + surv_single_coeffs[2, 2])) / (1 + exp(x = surv_single_coeffs[1, 2] + surv_single_coeffs[2, 2]))
p_h <- round(p_h, digits = 3)
```

And the estimated probability for survival in the Hand-pulling treatment is then `r p_h`.

Finally, we can compare the two by calculating the difference in probabilities, `r p_h` - `r p_c` = `r p_h - p_c`.

Note the explanation above does not discuss random effects of plot. So when reporting these values, it is best to say that this is the _average_ effect of treatment on survival.

#### 1.1.b Treatment as multiple predictors

The alternative approach is to treat each type of treatment as a separate variable:

$$
Log{-}odds \enspace Survival = \beta_0 + \beta_1 \times Javalina + \beta_2 \times Shade + \\ 
\beta_3 \times Weed \enspace eating + \beta_4 \times Hand \enspace pulling + b_0
$$

Where $b_0$ is the random intercept for plot. This simple model does _not_ incorporate interaction effects, although a richer model could include those. For example, the interaction between Javalina protection and Shade is significant (results not shown) and may explain the difference between Javalina protection alone and Javalina protection plus shade in 1.1.a, above.

```{r survival-multiple-treatment, warning = FALSE}
surv_multi <- glmer(formula = Status ~ Javalina + Shade + Weed_eating + Hand_pulling + (1|plot),
                    data = agave_data,
                    family = binomial(link = "logit"))
surv_multi_summary <- summary(surv_multi)

# Pull out the coefficients
surv_multi_coeffs <- surv_multi_summary$coefficients

# Tidy up coefficients, some adjustments necessary given deprecation of 
# tidy.matrix
surv_multi_coeffs <- bind_cols(data.frame(rownames(surv_multi_coeffs)),
                               data.frame(round(x = surv_multi_coeffs, digits = 4)))

# Update column names
colnames(surv_multi_coeffs) <- c("Predictor", "Estimate", "Std.Error", "z.value", "p.value")

# Remove the trailing "1" from predictors
surv_multi_coeffs$Predictor <- gsub(pattern = "1",
                                    replacement = "",
                                    x = surv_multi_coeffs$Predictor)

# Replace underscores with spaces
surv_multi_coeffs$Predictor <- gsub(pattern = "_",
                                    replacement = " ",
                                    x = surv_multi_coeffs$Predictor)

# Ensure small p-values are not shown as zero
surv_multi_coeffs$p.value <- as.character(ifelse(
  test = surv_multi_coeffs$p.value < 1e-5,
  yes = signif(x = surv_multi_coeffs$p.value, digits = 5),
  no = round(x = surv_multi_coeffs$p.value, digits = 5)))

knitr::kable(x = surv_multi_coeffs[, c(1, 2, 3, 5)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```

#### 1.1.c Treatment as multiple predictors with interaction effects

If this model is expanded to include interaction effects:

$\begin{aligned}
Log{-}odds \enspace Survival &= \beta_0 + \beta_1 \times Javalina + \beta_2 \times Shade + \beta_3 \times Weed \enspace eating + \beta_4 \times Hand \enspace pulling \\
         &+ \beta_5 \times Javalina \times Shade + \beta_6 \times Javalina \times Weed \enspace eating \\
         &+ \beta_7 \times Javalina \times Hand \enspace pulling + \beta_8 \times Shade \times Weed \enspace eating \\
         &+ \beta_9 \times Shade \times Hand \enspace pulling + b_0
\end{aligned}$

```{r survival-multiple-interactions, warning = FALSE}
# Including interaction effects, but not S+W
surv_interact <- glmer(formula = Status ~ Javalina + Shade + Weed_eating + Hand_pulling + 
                      Javalina * Shade + Javalina * Weed_eating + Javalina * Hand_pulling +
                      Shade * Weed_eating + Shade * Hand_pulling + (1|plot),
                    data = agave_data,
                    family = binomial(link = "logit"))
surv_interact_summary <- summary(surv_interact)

# Pull out the coefficients
surv_interact_coeffs <- surv_interact_summary$coefficients

# Tidy up coefficients
surv_interact_coeffs <- bind_cols(data.frame(rownames(surv_interact_coeffs)),
                                  data.frame(round(x = surv_interact_coeffs, digits = 4)))

# Update column names
colnames(surv_interact_coeffs) <- c("Predictor", "Estimate", "Std.Error", "z.value", "p.value")

# Remove the trailing "1" from predictors
surv_interact_coeffs$Predictor <- gsub(pattern = "1",
                                    replacement = "",
                                    x = surv_interact_coeffs$Predictor)

# Replace underscores with spaces
surv_interact_coeffs$Predictor <- gsub(pattern = "_",
                                    replacement = " ",
                                    x = surv_interact_coeffs$Predictor)

# Replace colon with times sign
surv_interact_coeffs$Predictor <- gsub(pattern = ":",
                                    replacement = " x ",
                                    x = surv_interact_coeffs$Predictor)

# Ensure small p-values are not shown as zero
surv_interact_coeffs$p.value <- as.character(ifelse(
  test = surv_interact_coeffs$p.value < 1e-5,
  yes = signif(x = surv_interact_coeffs$p.value, digits = 5),
  no = round(x = surv_interact_coeffs$p.value, digits = 5)))

knitr::kable(x = surv_interact_coeffs[, c(1, 2, 3, 5)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```

### 1.2. How does treatment affect agave size?

In this section, individual agave sizes (measured by number of leaves) is a continuous response variable in linear regression mixed-effects models. The data are restricted to cases where there was a live agave (N = `r nrow(live_agave_data)`). Furthermore, only measurements for a maximum of three agaves per row were used in analyses.

```{r prepare-size, warning = FALSE}
# Want a box plot with Treatment on x-axis, # leaves on y
agave_sizes <- live_agave_data %>%
  select(Treatment, live_leaf_number)

# Put label at end of upper whisker, which is the 95% quantile of sizes
size_whisker <- agave_sizes %>%
  ungroup() %>%
  group_by(Treatment) %>%
  summarize(upper_whisker = quantile(x = live_leaf_number, prob = 0.95))

# Merge survivorship values (text for plot) with whisker values (for 
# positioning) text on the plot
survive_text_size <- merge(x = survivorship,
                           y = size_whisker,
                           by = "Treatment")

# Re-level for plotting purposes
agave_sizes$Treatment <- factor(agave_sizes$Treatment,
                                 levels = c("C", "J", "J+S", "J+H", "J+W",
                                            "S", "S+H", "S+W", "H", "W"))
```

#### 1.2.a Treatment as a single predictor

The first model considers Treatment as a single predictor variable.

$$
\# Leaves = \beta_0 + \beta_1 \times Treatment + b_0
$$

Where $b_0$ is the random intercept for plot.

```{r size-single-treatment, warning = FALSE}
# Run model with plot as a random effect
size_single_model <- lmerTest::lmer(formula = live_leaf_number ~ Treatment + (1|plot),
                    data = live_agave_data)
size_single_summary <- summary(size_single_model)

# Pull out the coefficients
size_single_coeffs <- size_single_summary$coefficients

# Coerce to a data frame
size_single_coeffs <- as.data.frame(size_single_coeffs)

# Add rownames as first column
size_single_coeffs <- cbind(Predictor = rownames(size_single_coeffs), 
                            size_single_coeffs)
rownames(size_single_coeffs) <- NULL

# Update column names
colnames(size_single_coeffs) <- c("Predictor", "Estimate", "Std.Error", "df", "z.value", "p.value")

# Remove "Treatment"
size_single_coeffs$Predictor <- gsub(pattern = "Treatment",
                                     replacement = "",
                                     x = size_single_coeffs$Predictor)

# Ensure small p-values are not shown as zero
size_single_coeffs$p.value <- as.character(ifelse(
  test = size_single_coeffs$p.value < 1e-5,
  yes = signif(x = size_single_coeffs$p.value, digits = 5),
  no = round(x = size_single_coeffs$p.value, digits = 5)))

knitr::kable(x = size_single_coeffs[, c(1, 2, 3, 6)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```

_Note_: There are several Plot by Treatment combinations with zero measurements for leaf count and at least one Treatment level (W) where there was a _single_ leaf count measurement. This could potentially influence this particular analysis.

```{r size-single-post-hoc}
# Run Tukey post-hoc tests for pairwise comparisons
size_single_post_hoc <- emmeans(size_single_model, 
                                "Treatment", 
                                adjust = "tukey")

# Extract the pairwise contrasts table
size_single_contrasts <- as.data.frame(pairs(size_single_post_hoc))

# Only concerned with values relative to control treatment
size_single_contrasts <- size_single_contrasts[substr(x = size_single_contrasts$contrast, start = 1, stop = 3) == "C -", ]

# Make a nice format for printing before reducing to only significant effects
size_single_contrasts_print <- size_single_contrasts
size_single_contrasts_print$contrast <- gsub(x = size_single_contrasts_print$contrast,
                                             pattern = "C - ",
                                             replacement = "")

# And will only need to add asterisks where the post hoc tests were significant
size_single_contrasts <- size_single_contrasts[size_single_contrasts$p.value < 0.05, ]

if (nrow(size_single_contrasts) > 0) {
  # Extract the name of the treatments that differ from the control; will use 
  # these to identify the corresponding level in the Treatment factor so we can 
  # find x-axis placement of the asterisk
  size_single_diffs <- gsub(x = size_single_contrasts$contrast,
                            pattern = "C - ",
                            replacement = "")
  
  # Will need to use survive_text_size to get appropriate placement of asterisks 
  # in y dimension
  size_single_asterisks <- survive_text_size[survive_text_size$Treatment %in% size_single_diffs, ]
  size_single_asterisks$text <- "*"
}
```

_Post-hoc_ comparisons among treatments, showing results of Tukey test for significant differences from the Control treatment:

```{r size-single-post-hoc-table}
knitr::kable(x = size_single_contrasts_print[, c(1, 5, 6)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "t value", "P-value"))
```

```{r plot-size, warning = FALSE}
size_caption <- boxplot_text
if (nrow(size_single_contrasts) > 0) {
  size_caption <- paste0(size_caption, " ", asterisk_text)
}

agave_size_plot <- ggplot(data = agave_sizes, 
                            mapping = aes(x = Treatment, y = live_leaf_number)) +
  stat_summary(fun.data = boxplot_quantiles, geom = "boxplot") +
  # stat_summary(fun.y = boxplot_outliers, geom = "point") +
  labs(title = "Figure 1.2. Agave size by treatment",
       subtitle = "Numbers in plot show mean survivorship for treatment",
       x = "Treatment",
       y = "Number of leaves") +
  geom_text(data = survive_text_size,
            label = survive_text_size$mean_survivorship, # referring to bare column won't work
            nudge_y = 0.7, # move labels above upper whisker
            mapping = aes(x = Treatment, y = upper_whisker),
            size = 4,
            family = "Times New Roman") +
  theme_bw() +
  theme(text = element_text(family = "Times New Roman"))

# Only add asterisks if there were significant post-hoc differences
if (nrow(size_single_contrasts) > 0) {
  agave_size_plot <- agave_size_plot + 
    geom_text(data = size_single_asterisks,
              label = size_single_asterisks$text,
              nudge_y = 0.1,
              nudge_x = 0.1,
              mapping = aes(x = Treatment, y = upper_whisker),
              size = 5,
              family = "Times New Roman")
}
print(agave_size_plot)
suppressMessages(expr = ggsave(filename = "output/agave-size-plot.pdf", plot = agave_size_plot))
```
`r size_caption`

#### 1.2.b Treatment as multiple predictors

The second model separates out the four treatment types into separate variables:

$$
\# Leaves = \beta_0 + \beta_1 \times Javalina + \beta_2 \times Shade + \beta_3 \times Weed \enspace eating + \\
\beta_4 \times Hand \enspace pulling + b_0
$$

Where $b_0$ is the random intercept for plot.

```{r size-multi-treatment, warning = FALSE}
# Run model with plot as a random effect
size_multi_model <- lmerTest::lmer(formula = live_leaf_number ~ Javalina + Shade + Weed_eating + Hand_pulling + (1|plot),
                    data = live_agave_data)
size_multi_summary <- summary(size_multi_model)

# Pull out the coefficients
size_multi_coeffs <- size_multi_summary$coefficients

# Coerce to a data frame
size_multi_coeffs <- as.data.frame(size_multi_coeffs)

# Add rownames as first column
size_multi_coeffs <- cbind(Predictor = rownames(size_multi_coeffs), 
                            size_multi_coeffs)
rownames(size_multi_coeffs) <- NULL

# Update column names
colnames(size_multi_coeffs) <- c("Predictor", "Estimate", "Std.Error", "df", "z.value", "p.value")

# Remove trailing "1" from Predictor column
size_multi_coeffs$Predictor <- gsub(pattern = "1",
                                     replacement = "",
                                     x = size_multi_coeffs$Predictor)

# Replace underscores in predictor names
size_multi_coeffs$Predictor <- gsub(pattern = "_",
                                     replacement = " ",
                                     x = size_multi_coeffs$Predictor)

# Ensure small p-values are not shown as zero
size_multi_coeffs$p.value <- as.character(ifelse(
  test = size_multi_coeffs$p.value < 1e-5,
  yes = signif(x = size_multi_coeffs$p.value, digits = 5),
  no = round(x = size_multi_coeffs$p.value, digits = 5)))

knitr::kable(x = size_multi_coeffs[, c(1, 2, 3, 6)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```

#### 1.2.c Treatment as multiple predictors with interaction effects

A model with interaction effects is:

$\begin{aligned}
\# Leaves &= \beta_0 + \beta_1 \times Javalina + \beta_2 \times Shade + \beta_3 \times Weed \enspace eating + \beta_4 \times Hand \enspace pulling \\
         &+ \beta_5 \times Javalina \times Shade + \beta_6 \times Javalina \times Weed \enspace eating \\
         &+ \beta_7 \times Javalina \times Hand \enspace pulling + \beta_8 \times Shade \times Weed \enspace eating \\
         &+ \beta_9 \times Shade \times Hand \enspace pulling + b_0
\end{aligned}$

```{r size-multi-interactions, warning = FALSE}
# Run model with plot as a random effect
size_interact_model <- lmerTest::lmer(formula = live_leaf_number ~ Javalina + Shade + Weed_eating + Hand_pulling + 
                                     Javalina * Shade + Javalina * Weed_eating + Javalina * Hand_pulling +
                                     Shade * Weed_eating + Shade * Hand_pulling + (1|plot),
                    data = live_agave_data)
size_interact_summary <- summary(size_interact_model)

# Pull out the coefficients
size_interact_coeffs <- size_interact_summary$coefficients

# Coerce to a data frame
size_interact_coeffs <- as.data.frame(size_interact_coeffs)

# Add rownames as first column
size_interact_coeffs <- cbind(Predictor = rownames(size_interact_coeffs), 
                            size_interact_coeffs)
rownames(size_interact_coeffs) <- NULL

# Update column names
colnames(size_interact_coeffs) <- c("Predictor", "Estimate", "Std.Error", "df", "z.value", "p.value")

# Remove trailing "1" from Predictor column
size_interact_coeffs$Predictor <- gsub(pattern = "1",
                                     replacement = "",
                                     x = size_interact_coeffs$Predictor)

# Replace underscores in predictor names
size_interact_coeffs$Predictor <- gsub(pattern = "_",
                                     replacement = " ",
                                     x = size_interact_coeffs$Predictor)

# Replace colon with times sign
size_interact_coeffs$Predictor <- gsub(pattern = ":",
                                     replacement = " x ",
                                     x = size_interact_coeffs$Predictor)

# Ensure small p-values are not shown as zero
size_interact_coeffs$p.value <- as.character(ifelse(
  test = size_interact_coeffs$p.value < 1e-5,
  yes = signif(x = size_interact_coeffs$p.value, digits = 5),
  no = round(x = size_interact_coeffs$p.value, digits = 5)))

knitr::kable(x = size_interact_coeffs[, c(1, 2, 3, 6)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```

## 2. How do the W and H treatments and agaves affect the percent of Lehmann cover?

In these analyses, the effect of agaves is modeled in two ways:

1. Agave size (i.e. the number of leaves)
2. Presence or absence of a live agave

_Note_ in these analyses (Section 2), only treatments W and H _sensu stricto_ were considered. That is, data from rows with treatments J+H, J+W, S+H, and S+W are not included in plots & analyses.

### 2.1 How do selected treatments and agave size affect percent cover?

```{r cover-data-live-prep, warning = FALSE}
# Need to reduce data to only treatments H and W
cover_data_live <- live_agave_data[live_agave_data$Treatment %in% c("C", "H", "W"), ]

# Drop rows missing percent cover data
cover_data_live <- cover_data_live[!(is.na(cover_data_live$areial_cover)), ]

cover_data_live$Treatment <- factor(x = cover_data_live$Treatment)

# Only 18 rows of data when H, W, and C are included. Too few for mixed-effects
# Running linear regression early so we can add lines to plot
cover_size_model <- lm(formula = areial_cover ~ Treatment + live_leaf_number, data = cover_data_live)
cover_size_summary <- summary(cover_size_model)

cover_size_coeffs <- cover_size_summary$coefficients

# Coerce to a data frame
cover_size_coeffs <- as.data.frame(cover_size_coeffs)
```

Here we are interested to know how certain treatments and the _size_ of the agave plants affect the percent cover of Lehman lovegrass (N = `r nrow(cover_data_live)`). 

```{r plot-cover-size}
# control_model <- B0 + B2 * live_leaf_number
# hand_pulling_model <- B0 + B1 + B2 * live_leaf_number
# Find limits of data and predict those limits for line ends
# For Control treatment
control_limits <- c(min(cover_data_live$live_leaf_number[cover_data_live$Treatment == "C"]),
                    max(cover_data_live$live_leaf_number[cover_data_live$Treatment == "C"]))
control_line <- data.frame(Treatment = "C",
                              live_leaf_number = control_limits)
control_line$areial_cover <- predict(cover_size_model, newdata = control_line)
rm(control_limits)
# For Hand-pulling treatment
hand_pulling_limits <- c(min(cover_data_live$live_leaf_number[cover_data_live$Treatment == "H"]),
                         max(cover_data_live$live_leaf_number[cover_data_live$Treatment == "H"]))
hand_pulling_line <- data.frame(Treatment = "H",
                                   live_leaf_number = hand_pulling_limits)
hand_pulling_line$areial_cover <- predict(cover_size_model, newdata = hand_pulling_line)
rm(hand_pulling_limits)

cover_size_plot <- ggplot(data = cover_data_live, 
                          mapping = aes(x = live_leaf_number, y = areial_cover,
                                        group = Treatment, fill = Treatment,
                                        shape = Treatment)) +
  geom_line(data = control_line, color = "#787878") +
  geom_line(data = hand_pulling_line, color = "#D8B365") +
  geom_point(size = 2.0, alpha = 0.75) +
  scale_fill_manual(values = c("#787878", "#D8B365", "#5AB4AC"),
                    labels = c("Control", "Hand-pulling", "Weed-eating")) +
  scale_shape_manual(values = c(21, 22, 24), # Circle, square, triangle
                     labels = c("Control", "Hand-pulling", "Weed-eating")) +
  xlab(label = "Number of leaves") +
  ylab(label = "Percent cover") +
  ggtitle(label = "Figure 2.1. Percent Lehmann cover by agave size") +
  theme_bw() +
  theme(text = element_text(family = "Times New Roman"))
print(cover_size_plot)
suppressMessages(expr = ggsave(filename = "output/cover-size-plot.pdf", plot = cover_size_plot))
```
Note in the plot above, there are some points with identical values, e.g. there are two observations where the number of leaves was 4 and percent cover was 12%.


Ideally we would use a mixed-effect model with linear regression:

$$
\% Lehmann \enspace cover = \beta_0 + \beta_1 \times Treatment + \beta_2 \times \# Leaves + b_0
$$

Where $b_0$ is the random intercept for plot. However, when considering _only_ the samples from H and W (and control) treatments, there are too few samples (N = `r sum(!is.na(cover_data_live$live_leaf_number))`) to run a mixed effect model. A good old fashioned linear regression model is then:

$$
\% Lehmann \enspace cover = \beta_0 + \beta_1 \times Treatment + \beta_2 \times \# Leaves
$$

```{r cover-analysis-size, warning = FALSE}
# Add rownames as first column
cover_size_coeffs <- cbind(Predictor = rownames(cover_size_coeffs),
                      cover_size_coeffs)
rownames(cover_size_coeffs) <- NULL

# Update column names
colnames(cover_size_coeffs) <- c("Predictor", "Estimate", "Std.Error", "t.value", "p.value")

# Replace "Treatment" values
cover_size_coeffs$Predictor <- gsub(pattern = "TreatmentH",
                               replacement = "Hand-pulling",
                               x = cover_size_coeffs$Predictor)
cover_size_coeffs$Predictor <- gsub(pattern = "TreatmentW",
                               replacement = "Weed-eating",
                               x = cover_size_coeffs$Predictor)

# Replace live_leave_number with human-readable version
cover_size_coeffs$Predictor <- gsub(pattern = "live_leaf_number",
                               replacement = "Agave size",
                               x = cover_size_coeffs$Predictor)

# Ensure small p-values are not shown as zero
cover_size_coeffs$p.value <- as.character(ifelse(
  test = cover_size_coeffs$p.value < 1e-5,
  yes = signif(x = cover_size_coeffs$p.value, digits = 5),
  no = round(x = cover_size_coeffs$p.value, digits = 5)))

knitr::kable(x = cover_size_coeffs[, c(1, 2, 3, 5)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```

_Note_: Similar to question 1.2, there are several H/W treatments with zero leaf counts. It may be necessary instead to evaluate a model that does not include the number of agave leaves.

### 2.2 How do selected treatments and the presence of a live agave affect percent cover?

```{r cover-data-all-prep}
# Extract only those treatments of interest
cover_data_all <- agave_data[agave_data$Treatment %in% c("C", "H", "W"), ]
cover_data_all$Treatment <- factor(x = cover_data_all$Treatment)
cover_data_all$Status <- factor(x = cover_data_all$Status)

# Drop rows missing percent cover data
cover_data_all <- cover_data_all[!is.na(cover_data_all$areial_cover), ]
```

In contrast to 2.1, we instead use presence or absence of a live agave in the model (N = `r nrow(cover_data_all)`). 

```{r plot-cover-pa}
cover_data_all$agave <- "Present"
cover_data_all$agave[cover_data_all$Status == 0] <- "Absent"
cover_data_all$agave <- factor(x = cover_data_all$agave)

cover_pa_caption <- boxplot_text

cover_pa_plot <- ggplot(data = cover_data_all, 
                          mapping = aes(x = agave, y = areial_cover,
                                        fill = Treatment)) +
  stat_summary(fun.data = boxplot_quantiles, 
               geom = "boxplot",
               position = position_dodge(width = 0.7),
               width = 0.5) +
  scale_fill_manual(values = c("#787878", "#D8B365", "#5AB4AC"),
                     labels = c("Control", "Hand-pulling", "Weed-eating")) +
  labs(x = "Agave",
       y = "Percent cover",
       title = "Figure 2.2. Percent Lehmann cover by agave presence") +
  theme_bw() +
  theme(text = element_text(family = "Times New Roman"))
print(cover_pa_plot)
suppressMessages(expr = ggsave(filename = "output/cover-pa-plot.pdf", plot = cover_pa_plot))
```
`r cover_pa_caption`

We use a mixed-effect model:

$$
\% Lehmann \enspace cover = \beta_0 + \beta_1 \times Treatment + \beta_2 \times Agave + b_0
$$
where _Agave_ is a binary predictor, indicating whether or not a live agave was present and $b_0$ is the random intercept for plot.

```{r cover-analysis-pa, warning = FALSE}
# Run linear model with plot as random effect
cover_model_pa <- lmerTest::lmer(formula = areial_cover ~ Treatment + Status + (1|plot),
                                 data = cover_data_all)
cover_pa_summary <- summary(cover_model_pa)

# Extract coefficients
cover_pa_coeffs <- cover_pa_summary$coefficients

# Coerce to a data frame
cover_pa_coeffs <- as.data.frame(cover_pa_coeffs)

# Add rownames as first column
cover_pa_coeffs <- cbind(Predictor = rownames(cover_pa_coeffs),
                      cover_pa_coeffs)
rownames(cover_pa_coeffs) <- NULL

# Update column names
colnames(cover_pa_coeffs) <- c("Predictor", "Estimate", "Std.Error", "df", 
                               "t.value", "p.value")

# Replace "Treatment" values
cover_pa_coeffs$Predictor <- gsub(pattern = "TreatmentH",
                               replacement = "Hand-pulling",
                               x = cover_pa_coeffs$Predictor)
cover_pa_coeffs$Predictor <- gsub(pattern = "TreatmentW",
                               replacement = "Weed-eating",
                               x = cover_pa_coeffs$Predictor)

# Replace Status1 with human-readable version
cover_pa_coeffs$Predictor <- gsub(pattern = "Status1",
                               replacement = "Agave presence",
                               x = cover_pa_coeffs$Predictor)

# Ensure small p-values are not shown as zero
cover_pa_coeffs$p.value <- as.character(ifelse(
  test = cover_pa_coeffs$p.value < 1e-5,
  yes = signif(x = cover_pa_coeffs$p.value, digits = 5),
  no = round(x = cover_pa_coeffs$p.value, digits = 5)))

knitr::kable(x = cover_pa_coeffs[, c(1, 2, 3, 6)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```

## 3. How does percent cover affect survival and size of agaves?

### 3.1 How does percent cover affect agave survival?

Where survival is the total number of agaves alive. This is probably best addressed with an expanded version of the model presented in 1.1.a, above (N = `r nrow(agave_data)`).

$$
Log{-}odds \enspace Survival = \beta_0 + \beta_1 \times Treatment + \beta_2 \times \% Cover + b_0
$$

Where $b_0$ is the random intercept for plot.

```{r survival-treatment-cover, warning = FALSE}
# Treating "Treatment" as a single variable
# Will most likely fail to converge
surv_single_cover_model <- glmer(formula = Status ~ Treatment + areial_cover + (1|plot),
                                 data = agave_data[!is.na(agave_data$areial_cover), ],
                                 family = binomial(link = "logit"))
# Retrieve model estimates, for second run
ss <- getME(surv_single_cover_model, name = c("theta", "fixef"))

# Re-run model, starting with parameter estimates from first try
surv_single_cover_model <- update(surv_single_cover_model, start = ss)
surv_single_cover_summary <- summary(surv_single_cover_model)

surv_single_cover_coeffs <- surv_single_cover_summary$coefficients

# Tidy up coefficients
surv_single_cover_coeffs <- bind_cols(data.frame(rownames(surv_single_cover_coeffs)),
                                      data.frame(round(surv_single_cover_coeffs, digits = 4)))

# Clean up column names
colnames(surv_single_cover_coeffs) <- c("Predictor", "Estimate", "Std.Error", "z.value", "p.value")

# Remove "Treatment"
surv_single_cover_coeffs$Predictor <- gsub(pattern = "Treatment",
                                           replacement = "",
                                           x = surv_single_cover_coeffs$Predictor)

# Make areial_cover more human readable
surv_single_cover_coeffs$Predictor <- gsub(pattern = "areial_cover",
                                           replacement = "% Cover Lehman lovegrass",
                                           x = surv_single_cover_coeffs$Predictor)

# Ensure small p-values are not shown as zero
surv_single_cover_coeffs$p.value <- as.character(ifelse(
  test = surv_single_cover_coeffs$p.value < 1e-5,
  yes = signif(x = surv_single_cover_coeffs$p.value, digits = 5),
  no = round(x = surv_single_cover_coeffs$p.value, digits = 5)))

knitr::kable(x = surv_single_cover_coeffs[, c(1, 2, 3, 5)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```

### 3.2 How does percent cover affect agave size?

$$
\# Leaves = \beta_0 + \beta_1 \times Treatment + \beta_2 \times \% Cover + b_0
$$

Where $b_0$ is the random intercept for plot. This is a modification of the model presented in 1.2.a, above (N = `r nrow(live_agave_data)`).

```{r size-treatment-cover, warning = FALSE}
# Run model with plot as a random effect
size_single_cover_model <- lmerTest::lmer(formula = live_leaf_number ~ Treatment + areial_cover + (1|plot),
                    data = live_agave_data[!is.na(live_agave_data$areial_cover), ])
size_single_cover_summary <- summary(size_single_cover_model)

# Pull out the coefficients
size_single_cover_coeffs <- size_single_cover_summary$coefficients

# Coerce to a data frame
size_single_cover_coeffs <- as.data.frame(size_single_cover_coeffs)

# Add rownames as first column
size_single_cover_coeffs <- cbind(Predictor = rownames(size_single_cover_coeffs), 
                                  size_single_cover_coeffs)
rownames(size_single_cover_coeffs) <- NULL

# Update column names
colnames(size_single_cover_coeffs) <- c("Predictor", "Estimate", "Std.Error", "df", "z.value", "p.value")

# Remove "Treatment"
size_single_cover_coeffs$Predictor <- gsub(pattern = "Treatment",
                                     replacement = "",
                                     x = size_single_cover_coeffs$Predictor)

# Make areial_cover more human readable
size_single_cover_coeffs$Predictor <- gsub(pattern = "areial_cover",
                                           replacement = "% Cover Lehman lovegrass",
                                           x = size_single_cover_coeffs$Predictor)

# Ensure small p-values are not shown as zero
size_single_cover_coeffs$p.value <- as.character(ifelse(
  test = size_single_cover_coeffs$p.value < 1e-5,
  yes = signif(x = size_single_cover_coeffs$p.value, digits = 5),
  no = round(x = size_single_cover_coeffs$p.value, digits = 5)))

knitr::kable(x = size_single_cover_coeffs[, c(1, 2, 3, 6)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```
