---
title: "Palmer's Agave & Lehmann Lovegrass"
author: "Jeff Oliver"
date: "February 5, 2020"
output: 
  word_document: default
  pdf_document: default
---

```{r setup, include = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, fig.height = 3)
suppressPackageStartupMessages(library(lme4))     # glmer logistic models
suppressPackageStartupMessages(library(broom))    # Clean up stats tables
suppressPackageStartupMessages(library(lmerTest)) # lme models
suppressPackageStartupMessages(library(dplyr))    # Data wrangling
suppressPackageStartupMessages(library(ggplot2))  # Visualization
```

# Summary
A trio of questions on agave (_Agave palmeri_) survival and growth as effected by the invasive, Lehmann lovegrass (_Eragrostis lehmanniana_). To address these questions, I used a mixed-model approach, so the plot variable could be included as a random effect.

```{r data-import}
coronado_data <- read.csv(file = "data/coronado-data-clean.csv",
                          stringsAsFactors = FALSE)

# Treatments are sometimes referred to in different ways, i.e. J+S and S+J are 
# both present in data set, but mean the same thing.
coronado_data$Treatment[coronado_data$Treatment == "S+J"] <- "J+S"
coronado_data$Treatment[coronado_data$Treatment == "H+J"] <- "J+H" # may not occur
coronado_data$Treatment[coronado_data$Treatment == "W+J"] <- "J+W"
coronado_data$Treatment[coronado_data$Treatment == "W+S"] <- "S+W"

# The reference treatment should be control, C.

# Treatments will need to be put in separate columns for regression
# Javalina protection
# J and J+S and J+W and J+H
coronado_data$Javalina <- 0
coronado_data$Javalina[coronado_data$Treatment %in% c("J", "J+S", "J+W", "J+H")] <- 1
coronado_data$Javalina <- factor(coronado_data$Javalina)

# Shade cloth
# S and J+S and S+H and S+W
coronado_data$Shade <- 0
coronado_data$Shade[coronado_data$Treatment %in% c("S", "J+S", "S+H", "S+W")] <- 1
coronado_data$Shade <- factor(coronado_data$Shade)

# Weed eating
# W and J+W and W+H
coronado_data$Weed_eating <- 0
coronado_data$Weed_eating[coronado_data$Treatment %in% c("W", "J+W", "W+H", "S+W")] <- 1
coronado_data$Weed_eating <- factor(coronado_data$Weed_eating)

# Hand pulling
# H and J+H and S+H
coronado_data$Hand_pulling <- 0
coronado_data$Hand_pulling[coronado_data$Treatment %in% c("H", "J+H", "S+H")] <- 1
coronado_data$Hand_pulling <- factor(coronado_data$Hand_pulling)

# Add "Status" column to indicate live or dead for agaves
coronado_data$Status <- NA
coronado_data$Status[coronado_data$Species == "agave"] <- 1
coronado_data$Status[coronado_data$live_leaf_number %in% c("D", "D/P", "P")] <- 0

# Only need agave data for analyses
agave_data <- coronado_data[coronado_data$Species == "agave", ]

# Drop areial_cover.. column (will come from lovegrass rows)
to_drop <- which(colnames(agave_data) == "areial_cover")
agave_data <- agave_data[, -to_drop]

# But still need lehmann lovegarss [sic] cover for some analyses, so a merge
# is required
lehman_data <- coronado_data[coronado_data$Species == "Lehmann lovegarss", ]
lehman_data <- lehman_data[, c("plot", "Row", "plant.num", "areial_cover")]
agave_data <- merge(x = agave_data, y = lehman_data)
```

## 0. Data summary

Following data cleaning, the total number of replicates and plants in each treatment is:

```{r data-summary, message = FALSE}
agave_summary <- agave_data %>%
  group_by(Treatment) %>%
  summarize(num_reps = length(unique(paste0(plot, Row))),
            num_plants = n())

knitr::kable(x = agave_summary,
             format = "markdown", 
             row.names = FALSE,
             col.names = c("Treatment", "# Replicates", "# Plants"))
```

## 1. How does treatment affect agave survival and size?

The two response variables are:

1. The total number of live plants in a row (all those not marked as dead or predated)
2. The number of leaves on agave plants; the number of agaves measured varies among plot/treatment combinations

The inclusion of treatment in the models can be done in two different ways:

1. Treatment is treated as a single predictor variable, with `r length(unique(agave_data$Treatment))` levels, including the control.
2. Treatment is separated into multiple binary predictor variables; indicating whether or not a specific treatment (i.e. Javalina protection) was applied.

### 1.1 How does treatment affect agave survival _s.s._?

In this model, survival is treated as a binary response variable and a logistic regression model is applied (N = `r nrow(agave_data)`).

```{r plot-survival, warning = FALSE}
# Want a box plot with Treatment on x-axis, # live plants/plot on y
agave_counts <- agave_data %>%
  group_by(plot, Treatment) %>%
  summarize(num_alive = sum(Status))

# Re-level so Control (C) is reference and treatments are plotted in desired 
# order
agave_counts$Treatment <- factor(agave_counts$Treatment,
                                 levels = c("C", "J", "J+S", "J+H", "J+W",
                                            "S", "S+H", "S+W", "H", "W"))

agave_count_plot <- ggplot(data = agave_counts, 
                            mapping = aes(x = Treatment, y = num_alive)) +
  geom_boxplot() +
  xlab(label = "Treatment") +
  ylab(label = "# Live Agaves") +
  ggtitle(label = "Figure 1.1. Agave survival by treatment") +
  theme_bw()
print(agave_count_plot)
suppressMessages(expr = ggsave(filename = "output/agave-count-plot.pdf", plot = agave_count_plot))
```

#### 1.1.a Treatment as a single predictor

For the method of predicting based on treatment, there is a single fixed-effect in the model:

$$
Log{-}odds \enspace Survival = \beta_0 + \beta_1 \times Treatment + b_0
$$

Where $b_0$ is the random intercept for plot.

```{r survival-single-treatment, warning = FALSE}
# Treating "Treatment" as a single variable
surv_single <- glmer(formula = Status ~ Treatment + (1|plot),
                     data = agave_data,
                     family = binomial(link = "logit"))
surv_single_summary <- summary(surv_single)

# Pull out the coefficients
surv_single_coeffs <- surv_single_summary$coefficients

# Tidy up coefficients
surv_single_coeffs <- tidy(surv_single_coeffs)

# Update column names
colnames(surv_single_coeffs) <- c("Predictor", "Estimate", "Std.Error", "z.value", "p.value")

# Remove "Treatment"
surv_single_coeffs$Predictor <- gsub(pattern = "Treatment",
                                     replacement = "",
                                     x = surv_single_coeffs$Predictor)

knitr::kable(x = surv_single_coeffs[, c(1, 2, 3, 5)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```

```{r results = "asis"}
if (any(surv_single_coeffs$p.value < 1e-5)) {
  cat("\n_Note_: P-values reported as 0 are artifacts of rounding; they are not truly zero.")
}
```

#### 1.1.b Treatment as multiple predictors

The alternative approach is to treat each type of treatment as a separate variable:

$$
Log{-}odds \enspace Survival = \beta_0 + \beta_1 \times Javalina + \beta_2 \times Shade + \\ 
\beta_3 \times Weed \enspace eating + \beta_4 \times Hand \enspace pulling + b_0
$$

Where $b_0$ is the random intercept for plot. This simple model does _not_ incorporate interaction effects, although a richer model could include those. For example, the interaction between Javalina protection and Shade is significant (results not shown) and may explain the difference between Javalina protection alone and Javalina protection plus shade in 1.1.a, above.

```{r survival-multiple-treatment, warning = FALSE}
surv_multi <- glmer(formula = Status ~ Javalina + Shade + Weed_eating + Hand_pulling + (1|plot),
                    data = agave_data,
                    family = binomial(link = "logit"))
surv_multi_summary <- summary(surv_multi)

# Pull out the coefficients
surv_multi_coeffs <- surv_multi_summary$coefficients

# Tidy up coefficients
surv_multi_coeffs <- tidy(surv_multi_coeffs)

# Update column names
colnames(surv_multi_coeffs) <- c("Predictor", "Estimate", "Std.Error", "z.value", "p.value")

# Remove the trailing "1" from predictors
surv_multi_coeffs$Predictor <- gsub(pattern = "1",
                                    replacement = "",
                                    x = surv_multi_coeffs$Predictor)

# Replace underscores with spaces
surv_multi_coeffs$Predictor <- gsub(pattern = "_",
                                    replacement = " ",
                                    x = surv_multi_coeffs$Predictor)

knitr::kable(x = surv_multi_coeffs[, c(1, 2, 3, 5)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```

```{r results = "asis"}
if (any(surv_multi_coeffs$p.value < 1e-5)) {
  cat("\n_Note_: P-values reported as 0 are artifacts of rounding; they are not truly zero.")
}
```

#### 1.1.c Treatment as multiple predictors with interaction effects

If this model is expanded to include interaction effects:

$\begin{aligned}
Log{-}odds \enspace Survival &= \beta_0 + \beta_1 \times Javalina + \beta_2 \times Shade + \beta_3 \times Weed \enspace eating + \beta_4 \times Hand \enspace pulling \\
         &+ \beta_5 \times Javalina \times Shade + \beta_6 \times Javalina \times Weed \enspace eating \\
         &+ \beta_7 \times Javalina \times Hand \enspace pulling + \beta_8 \times Shade \times Weed \enspace eating \\
         &+ \beta_9 \times Shade \times Hand \enspace pulling + b_0
\end{aligned}$

```{r survival-multiple-interactions, warning = FALSE}
# Including interaction effects, but not S+W
surv_interact <- glmer(formula = Status ~ Javalina + Shade + Weed_eating + Hand_pulling + 
                      Javalina * Shade + Javalina * Weed_eating + Javalina * Hand_pulling +
                      Shade * Weed_eating + Shade * Hand_pulling + (1|plot),
                    data = agave_data,
                    family = binomial(link = "logit"))
surv_interact_summary <- summary(surv_interact)

# Pull out the coefficients
surv_interact_coeffs <- surv_interact_summary$coefficients

# Tidy up coefficients
surv_interact_coeffs <- tidy(surv_interact_coeffs)

# Update column names
colnames(surv_interact_coeffs) <- c("Predictor", "Estimate", "Std.Error", "z.value", "p.value")

# Remove the trailing "1" from predictors
surv_interact_coeffs$Predictor <- gsub(pattern = "1",
                                    replacement = "",
                                    x = surv_interact_coeffs$Predictor)

# Replace underscores with spaces
surv_interact_coeffs$Predictor <- gsub(pattern = "_",
                                    replacement = " ",
                                    x = surv_interact_coeffs$Predictor)

# Replace colon with times sign
surv_interact_coeffs$Predictor <- gsub(pattern = ":",
                                    replacement = " x ",
                                    x = surv_interact_coeffs$Predictor)

knitr::kable(x = surv_interact_coeffs[, c(1, 2, 3, 5)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```

```{r results = "asis"}
if (any(surv_interact_coeffs$p.value < 1e-5)) {
  cat("\n_Note_: P-values reported as 0 are artifacts of rounding; they are not truly zero.")
}
```

### 1.2. How does treatment affect agave size?

```{r prep-live-agave-data}
# Start by dropping all dead plants
live_agave_data <- agave_data[agave_data$Status == 1, ]

# Now all values in live_leaf_number should be numeric
live_agave_data$live_leaf_number <- as.integer(live_agave_data$live_leaf_number)

# Drop any remaining rows with NA for leaf count
live_agave_data <- live_agave_data[!is.na(live_agave_data$live_leaf_number), ]

# For plot & analyses, only consider a maximum of 3 leaves for any 
# plot/row/treatment combination (group %>% slice %>% ungroup)
max_agaves <- 3
live_agave_data <- live_agave_data %>%
  group_by(plot, Row) %>%
  slice(1:max_agaves) %>%
  ungroup()
```

In this section, individual agave sizes (measured by number of leaves) is a continuous response variable in linear regression mixed-effects models. The data are restricted to cases where there was a live agave (N = `r nrow(live_agave_data)`). Furthermore, only measurements for a maximum of three agaves per row were used in analyses.

```{r plot-size, warning = FALSE}
# Want a box plot with Treatment on x-axis, # leaves on y
agave_sizes <- live_agave_data %>%
  select(Treatment, live_leaf_number)

# Add text labels indicating survivorship for each treatment
# Start by calculating mean survivorship for each treatment
survivorship <- agave_data %>%
  group_by(Treatment) %>%
  summarize(mean_survivorship = round(x = mean(sum(Status)/n()), digits = 2))

# Calculate 75% quantile of # leaves for positioning mean survivorship on boxplot
# surv_quant <- live_agave_data %>%
#   group_by(Treatment) %>%
#   summarize(surv_75 = quantile(x = live_leaf_number, prob = 0.75))

# Put label at end of upper whisker, which is the largest value no further than
# 1.5 * IQR from the upper hinge (IQR is 0.75 - 0.25)
leaf_whisker <- live_agave_data %>%
  group_by(Treatment) %>%
  summarize(whisker_max = quantile(x = live_leaf_number, prob = 0.75) +
              1.5 * (quantile(x = live_leaf_number, prob = 0.75) -
              quantile(x = live_leaf_number, prob = 0.25)))

# Merge with agave data so we can find values for whisker
leaf_upper_whisker <- merge(x = live_agave_data,
                            y = leaf_whisker)

# Drop any values above whisker_max for each treatment, the find largest 
# remaining value
leaf_upper_whisker <- leaf_upper_whisker %>%
  filter(live_leaf_number <= whisker_max) %>%
  group_by(Treatment) %>%
  summarise(upper_whisker = max(live_leaf_number))

# Merge survivorship values (text for plot) with whisker values (for 
# positioning) text on the plot
agave_survivorship <- merge(x = survivorship,
                            y = leaf_upper_whisker,
                            by = "Treatment")

# Re-level for plotting purposes
agave_sizes$Treatment <- factor(agave_sizes$Treatment,
                                 levels = c("C", "J", "J+S", "J+H", "J+W",
                                            "S", "S+H", "S+W", "H", "W"))

agave_size_plot <- ggplot(data = agave_sizes, 
                            mapping = aes(x = Treatment, y = live_leaf_number)) +
  geom_boxplot() +
  labs(title = "Figure 1.2. Agave size by treatment",
       subtitle = "Numbers in plot show mean survivorship for treatment",
       x = "Treatment",
       y = "# Leaves") +
  # xlab(label = "Treatment") +
  # ylab(label = "# Leaves") +
  # ggtitle(label = "Figure 1.2. Agave size by treatment") +
  geom_text(data = agave_survivorship,
            label = agave_survivorship$mean_survivorship, # referring to bare column won't work
            nudge_y = 0.7, # move labels above upper whisker
            mapping = aes(x = Treatment, y = upper_whisker),
            size = 4) +
  theme_bw()
print(agave_size_plot)
suppressMessages(expr = ggsave(filename = "output/agave-size-plot.pdf", plot = agave_size_plot))
```

#### 1.2.a Treatment as a single predictor

The first model considers Treatment as a single predictor variable.

$$
\# Leaves = \beta_0 + \beta_1 \times Treatment + b_0
$$

Where $b_0$ is the random intercept for plot.

```{r size-single-treatment, warning = FALSE}
# Run model with plot as a random effect
size_single_model <- lmerTest::lmer(formula = live_leaf_number ~ Treatment + (1|plot),
                    data = live_agave_data)
size_single_summary <- summary(size_single_model)

# Pull out the coefficients
size_single_coeffs <- size_single_summary$coefficients

# Coerce to a data frame
size_single_coeffs <- as.data.frame(size_single_coeffs)

# Add rownames as first column
size_single_coeffs <- cbind(Predictor = rownames(size_single_coeffs), 
                            size_single_coeffs)
rownames(size_single_coeffs) <- NULL

# Update column names
colnames(size_single_coeffs) <- c("Predictor", "Estimate", "Std.Error", "df", "z.value", "p.value")

# Remove "Treatment"
size_single_coeffs$Predictor <- gsub(pattern = "Treatment",
                                     replacement = "",
                                     x = size_single_coeffs$Predictor)

knitr::kable(x = size_single_coeffs[, c(1, 2, 3, 6)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```

```{r results = "asis"}
if (any(size_single_coeffs$p.value < 1e-5)) {
  cat("\n_Note_: P-values reported as 0 are artifacts of rounding; they are not truly zero.")
}
```

_Note_: There are several Plot by Treatment combinations with zero measurements for leaf count and at least one Treatment level (W) where there was a _single_ leaf count measurement. This could potentially influence this particular analysis.

#### 1.2.b Treatment as multiple predictors

The second model separates out the four treatment types into separate variables:

$$
\# Leaves = \beta_0 + \beta_1 \times Javalina + \beta_2 \times Shade + \beta_3 \times Weed \enspace eating + \\
\beta_4 \times Hand \enspace pulling + b_0
$$

Where $b_0$ is the random intercept for plot.

```{r size-multi-treatment, warning = FALSE}
# Run model with plot as a random effect
size_multi_model <- lmerTest::lmer(formula = live_leaf_number ~ Javalina + Shade + Weed_eating + Hand_pulling + (1|plot),
                    data = live_agave_data)
size_multi_summary <- summary(size_multi_model)

# Pull out the coefficients
size_multi_coeffs <- size_multi_summary$coefficients

# Coerce to a data frame
size_multi_coeffs <- as.data.frame(size_multi_coeffs)

# Add rownames as first column
size_multi_coeffs <- cbind(Predictor = rownames(size_multi_coeffs), 
                            size_multi_coeffs)
rownames(size_multi_coeffs) <- NULL

# Update column names
colnames(size_multi_coeffs) <- c("Predictor", "Estimate", "Std.Error", "df", "z.value", "p.value")

# Remove trailing "1" from Predictor column
size_multi_coeffs$Predictor <- gsub(pattern = "1",
                                     replacement = "",
                                     x = size_multi_coeffs$Predictor)

# Replace underscores in predictor names
size_multi_coeffs$Predictor <- gsub(pattern = "_",
                                     replacement = " ",
                                     x = size_multi_coeffs$Predictor)

knitr::kable(x = size_multi_coeffs[, c(1, 2, 3, 6)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```

```{r results = "asis"}
if (any(size_multi_coeffs$p.value < 1e-5)) {
  cat("\n_Note_: P-values reported as 0 are artifacts of rounding; they are not truly zero.")
}
```

#### 1.2.c Treatment as multiple predictors with interaction effects

A model with interaction effects is:

$\begin{aligned}
\# Leaves &= \beta_0 + \beta_1 \times Javalina + \beta_2 \times Shade + \beta_3 \times Weed \enspace eating + \beta_4 \times Hand \enspace pulling \\
         &+ \beta_5 \times Javalina \times Shade + \beta_6 \times Javalina \times Weed \enspace eating \\
         &+ \beta_7 \times Javalina \times Hand \enspace pulling + \beta_8 \times Shade \times Weed \enspace eating \\
         &+ \beta_9 \times Shade \times Hand \enspace pulling + b_0
\end{aligned}$

```{r size-multi-interactions, warning = FALSE}
# Run model with plot as a random effect
size_interact_model <- lmerTest::lmer(formula = live_leaf_number ~ Javalina + Shade + Weed_eating + Hand_pulling + 
                                     Javalina * Shade + Javalina * Weed_eating + Javalina * Hand_pulling +
                                     Shade * Weed_eating + Shade * Hand_pulling + (1|plot),
                    data = live_agave_data)
size_interact_summary <- summary(size_interact_model)

# Pull out the coefficients
size_interact_coeffs <- size_interact_summary$coefficients

# Coerce to a data frame
size_interact_coeffs <- as.data.frame(size_interact_coeffs)

# Add rownames as first column
size_interact_coeffs <- cbind(Predictor = rownames(size_interact_coeffs), 
                            size_interact_coeffs)
rownames(size_interact_coeffs) <- NULL

# Update column names
colnames(size_interact_coeffs) <- c("Predictor", "Estimate", "Std.Error", "df", "z.value", "p.value")

# Remove trailing "1" from Predictor column
size_interact_coeffs$Predictor <- gsub(pattern = "1",
                                     replacement = "",
                                     x = size_interact_coeffs$Predictor)

# Replace underscores in predictor names
size_interact_coeffs$Predictor <- gsub(pattern = "_",
                                     replacement = " ",
                                     x = size_interact_coeffs$Predictor)

# Replace colon with times sign
size_interact_coeffs$Predictor <- gsub(pattern = ":",
                                     replacement = " x ",
                                     x = size_interact_coeffs$Predictor)

knitr::kable(x = size_interact_coeffs[, c(1, 2, 3, 6)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```

```{r results = "asis"}
if (any(size_interact_coeffs$p.value < 1e-5)) {
  cat("\n_Note_: P-values reported as 0 are artifacts of rounding; they are not truly zero.")
}
```

## 2. How do the W and H treatments and agaves affect the percent of Lehmann cover?

In these analyses, the effect of agaves is modeled in two ways:

1. Agave size (i.e. the number of leaves)
2. Presence or absence of a live agave

_Note_ in these analyses (Section 2), only treatments W and H _sensu stricto_ were considered. That is, data from rows with treatments J+H, J+W, S+H, and S+W are not included in plots & analyses.

### 2.1 How do selected treatments and agave size affect percent cover?

```{r cover-data-live-prep, warning = FALSE}
# Need to reduce data to only treatments H and W
cover_data_live <- live_agave_data[live_agave_data$Treatment %in% c("C", "H", "W"), ]

# Drop rows missing percent cover data
cover_data_live <- cover_data_live[!(is.na(cover_data_live$areial_cover)), ]

cover_data_live$Treatment <- factor(x = cover_data_live$Treatment)
```

Here we are interested to know how certain treatments and the _size_ of the agave plants affect the % cover of Lehman lovegrass (N = `r nrow(cover_data_live)`). 

```{r plot-cover-size}
cover_size_plot <- ggplot(data = cover_data_live, 
                          mapping = aes(x = live_leaf_number, y = areial_cover,
                                        group = Treatment, fill = Treatment)) +
  geom_point(size = 2.0, shape = 21, alpha = 0.75) +
  scale_fill_manual(values = c("#787878", "#D8B365", "#5AB4AC"),
                    labels = c("Control", "Hand-pulling", "Weed-eating")) +
  xlab(label = "# Leaves") +
  ylab(label = "% Cover") +
  ggtitle(label = "Figure 2.1. % Lehmann cover by agave size") +
  theme_bw()
print(cover_size_plot)
suppressMessages(expr = ggsave(filename = "output/cover-size-plot.pdf", plot = cover_size_plot))
```

Ideally we would use a mixed-effect model with linear regression:

$$
\% Lehmann \enspace cover = \beta_0 + \beta_1 \times Treatment + \beta_2 \times \# Leaves + b_0
$$

Where $b_0$ is the random intercept for plot. However, when considering _only_ the samples from H and W (and control) treatments, there are too few samples (N = `r sum(!is.na(cover_data_live$live_leaf_number))`) to run a mixed effect model. A good old fashioned linear regression model is then:

$$
\% Lehmann \enspace cover = \beta_0 + \beta_1 \times Treatment + \beta_2 \times \# Leaves
$$

```{r cover-analysis-size, warning = FALSE}
# Only 18 rows of data when H, W, and C are included. Too few for mixed-effects

# Run linear model with plot as random effect
# cover_size_model <- lmerTest::lmer(formula = areial_cover ~ Treatment + live_leaf_number + (1|plot),
#                               data = cover_data_live)

cover_size_model <- lm(formula = areial_cover ~ Treatment + live_leaf_number, data = cover_data_live)
cover_size_summary <- summary(cover_size_model)

cover_size_coeffs <- cover_size_summary$coefficients

# Coerce to a data frame
cover_size_coeffs <- as.data.frame(cover_size_coeffs)

# Add rownames as first column
cover_size_coeffs <- cbind(Predictor = rownames(cover_size_coeffs),
                      cover_size_coeffs)
rownames(cover_size_coeffs) <- NULL

# Replace "Treatment" values
cover_size_coeffs$Predictor <- gsub(pattern = "TreatmentH",
                               replacement = "Hand-pulling",
                               x = cover_size_coeffs$Predictor)
cover_size_coeffs$Predictor <- gsub(pattern = "TreatmentW",
                               replacement = "Weed-eating",
                               x = cover_size_coeffs$Predictor)

# Replace live_leave_number with human-readable version
cover_size_coeffs$Predictor <- gsub(pattern = "live_leaf_number",
                               replacement = "Agave size",
                               x = cover_size_coeffs$Predictor)

knitr::kable(x = cover_size_coeffs[, c(1, 2, 3, 5)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```

```{r results = "asis"}
if (any(cover_size_coeffs$`Pr(>|t|)` < 1e-5)) {
  cat("\n_Note_: P-values reported as 0 are artifacts of rounding; they are not truly zero.")
}
```

_Note_: Similar to question 1.2, there are several H/W treatments with zero leaf counts. It may be necessary instead to evaluate a model that does not include the number of agave leaves.

### 2.2 How do selected treatments and the presence of a live agave affect percent cover?

```{r cover-data-all-prep}
# Extract only those treatments of interest
cover_data_all <- agave_data[agave_data$Treatment %in% c("C", "H", "W"), ]
cover_data_all$Treatment <- factor(x = cover_data_all$Treatment)
cover_data_all$Status <- factor(x = cover_data_all$Status)

# Drop rows missing percent cover data
cover_data_all <- cover_data_all[!is.na(cover_data_all$areial_cover), ]
```

In contrast to 2.1, we instead use presence or absence of a live agave in the model (N = `r nrow(cover_data_all)`). 

```{r plot-cover-pa}
cover_data_all$agave <- "Present"
cover_data_all$agave[cover_data_all$Status == 0] <- "Absent"
cover_data_all$agave <- factor(x = cover_data_all$agave)

cover_pa_plot <- ggplot(data = cover_data_all, 
                          mapping = aes(x = agave, y = areial_cover,
                                        fill = Treatment)) +
  geom_boxplot() +
  scale_fill_manual(values = c("#787878", "#D8B365", "#5AB4AC"),
                     labels = c("Control", "Hand-pulling", "Weed-eating")) +
  xlab(label = "Agave") +
  ylab(label = "% Cover") +
  ggtitle(label = "Figure 2.2. % Lehmann cover by agave presence") +
  theme_bw()
print(cover_pa_plot)
suppressMessages(expr = ggsave(filename = "output/cover-pa-plot.pdf", plot = cover_pa_plot))
```

We use a mixed-effect model:

$$
\% Lehmann \enspace cover = \beta_0 + \beta_1 \times Treatment + \beta_2 \times Agave + b_0
$$
where _Agave_ is a binary predictor, indicating whether or not a live agave was present and $b_0$ is the random intercept for plot.

```{r cover-analysis-pa, warning = FALSE}
# Run linear model with plot as random effect
cover_model_pa <- lmerTest::lmer(formula = areial_cover ~ Treatment + Status + (1|plot),
                                 data = cover_data_all)
cover_pa_summary <- summary(cover_model_pa)

# Extract coefficients
cover_pa_coeffs <- cover_pa_summary$coefficients

# Coerce to a data frame
cover_pa_coeffs <- as.data.frame(cover_pa_coeffs)

# Add rownames as first column
cover_pa_coeffs <- cbind(Predictor = rownames(cover_pa_coeffs),
                      cover_pa_coeffs)
rownames(cover_pa_coeffs) <- NULL

# Replace "Treatment" values
cover_pa_coeffs$Predictor <- gsub(pattern = "TreatmentH",
                               replacement = "Hand-pulling",
                               x = cover_pa_coeffs$Predictor)
cover_pa_coeffs$Predictor <- gsub(pattern = "TreatmentW",
                               replacement = "Weed-eating",
                               x = cover_pa_coeffs$Predictor)

# Replace Status1 with human-readable version
cover_pa_coeffs$Predictor <- gsub(pattern = "Status1",
                               replacement = "Agave presence",
                               x = cover_pa_coeffs$Predictor)

knitr::kable(x = cover_pa_coeffs[, c(1, 2, 3, 6)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```

```{r results = "asis"}
if (any(cover_pa_coeffs$`Pr(>|t|)` < 1e-5)) {
  cat("\n_Note_: P-values reported as 0 are artifacts of rounding; they are not truly zero.")
}
```

## 3. How does percent cover affect survival and size of agaves?

### 3.1 How does percent cover affect agave survival?

Where survival is the total number of agaves alive. This is probably best addressed with an expanded version of the model presented in 1.1.a, above (N = `r nrow(agave_data)`).

$$
Log{-}odds \enspace Survival = \beta_0 + \beta_1 \times Treatment + \beta_2 \times \% Cover + b_0
$$

Where $b_0$ is the random intercept for plot.

```{r survival-treatment-cover, warning = FALSE}
# Treating "Treatment" as a single variable
# Will most likely fail to converge
surv_single_cover_model <- glmer(formula = Status ~ Treatment + areial_cover + (1|plot),
                                 data = agave_data[!is.na(agave_data$areial_cover), ],
                                 family = binomial(link = "logit"))
# Retrieve model estimates, for second run
ss <- getME(surv_single_cover_model, name = c("theta", "fixef"))

# Re-run model, starting with parameter estimates from first try
surv_single_cover_model <- update(surv_single_cover_model, start = ss)
surv_single_cover_summary <- summary(surv_single_cover_model)

surv_single_cover_coeffs <- surv_single_cover_summary$coefficients
surv_single_cover_coeffs <- tidy(surv_single_cover_coeffs)

# Clean up column names
colnames(surv_single_cover_coeffs) <- c("Predictor", "Estimate", "Std.Error", "z.value", "p.value")

# Remove "Treatment"
surv_single_cover_coeffs$Predictor <- gsub(pattern = "Treatment",
                                           replacement = "",
                                           x = surv_single_cover_coeffs$Predictor)

# Make areial_cover more human readable
surv_single_cover_coeffs$Predictor <- gsub(pattern = "areial_cover",
                                           replacement = "% Cover Lehman lovegrass",
                                           x = surv_single_cover_coeffs$Predictor)

knitr::kable(x = surv_single_cover_coeffs[, c(1, 2, 3, 5)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```

```{r results = "asis"}
if (any(surv_single_cover_coeffs$p.value < 1e-5)) {
  cat("\n_Note_: P-values reported as 0 are artifacts of rounding; they are not truly zero.")
}
```

### 3.2 How does percent cover affect agave size?

$$
\# Leaves = \beta_0 + \beta_1 \times Treatment + \beta_2 \times \% Cover + b_0
$$

Where $b_0$ is the random intercept for plot. This is a modification of the model presented in 1.2.a, above (N = `r nrow(live_agave_data)`).

```{r size-treatment-cover, warning = FALSE}
# Run model with plot as a random effect
size_single_cover_model <- lmerTest::lmer(formula = live_leaf_number ~ Treatment + areial_cover + (1|plot),
                    data = live_agave_data[!is.na(live_agave_data$areial_cover), ])
size_single_cover_summary <- summary(size_single_cover_model)

# Pull out the coefficients
size_single_cover_coeffs <- size_single_cover_summary$coefficients

# Coerce to a data frame
size_single_cover_coeffs <- as.data.frame(size_single_cover_coeffs)

# Add rownames as first column
size_single_cover_coeffs <- cbind(Predictor = rownames(size_single_cover_coeffs), 
                            size_single_cover_coeffs)
rownames(size_single_cover_coeffs) <- NULL

# Update column names
colnames(size_single_cover_coeffs) <- c("Predictor", "Estimate", "Std.Error", "df", "z.value", "p.value")

# Remove "Treatment"
size_single_cover_coeffs$Predictor <- gsub(pattern = "Treatment",
                                     replacement = "",
                                     x = size_single_cover_coeffs$Predictor)

# Make areial_cover more human readable
size_single_cover_coeffs$Predictor <- gsub(pattern = "areial_cover",
                                           replacement = "% Cover Lehman lovegrass",
                                           x = size_single_cover_coeffs$Predictor)

knitr::kable(x = size_single_cover_coeffs[, c(1, 2, 3, 6)], 
             format = "markdown",
             row.names = FALSE,
             digits = 5,
             col.names = c("Predictor", "Coefficient Estimate", "Error", "P-value"))
```

```{r results = "asis"}
if (any(size_single_cover_coeffs$p.value < 1e-5)) {
  cat("\n_Note_: P-values reported as 0 are artifacts of rounding; they are not truly zero.")
}
```
